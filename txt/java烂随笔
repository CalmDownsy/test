Q1: 测试开发工程师
A1：1.JMeter/LoadRunner测试工具；
    2.Linux-shell;
    3.Jenkins;
    4.Java && Python
    5.测试工具开发，开元测试工具二次开发 **
    5.Docker

-------------------------------------------------------------------------

Q1: 成员内部类中不能包含静态变量或方法
A1: 应该与生命周期有关。首先，理一下类加载的概念，类的使用一般经过编译、加载、初始化的阶段，加载只有在类第一次被调用的时候才会发生，
    如，new ()，此时，静态成员会记载进静态方法区中;成员内部类也就是外部类的非静态成员，
    因此，成员内部类的使用必须要在外部类实例化之后，而静态成员是在类实例化之前就存在于内存中的，生命周期相互矛盾。
    再者，静态成员是不属于某个具体对象的，属于类的变量，外部类想通过内部类访问其静态成员的一般方法是Outter.Inner.STATIC，
    此时需要外部类、内部类都已经加载而不需要实例化，上面的描述也可知，非静态内部类此时是会加载的。

Q2: 与成员内部类相对应的就是静态内部类
A2: 与成员内部相似，静态内部类可以看做是外部类的静态成员，即它的加载时机与外部类是一致的，不需要等到外部类实例化的，
    也就是说不依赖于外部类的，但同时静态内部类也不能访问外部类的非静态成员与方法，同样与生命周期有关。

    static成员是在JVM的CLASSLOADER加载类的时候初始化的，而非static的成员是在创建对象，
即new 操作的时候才初始化的；类加载的时候初始化static的成员，此时static 已经分配内存空间，
所以可以访问；非static的成员还没有通过new创建对象而进行初始化，所以必然不可以访问。
简单点说：静态成员属于类,不需要生成对象就存在了.而非静态需要生成对象才产生，所以静态成员不能直接访问.  
下面说说静态的特点：
     1.随着类的加载而加载——静态会随着类的消失而消失，说明静态的生命周期最长
     2.优先于对象的存在——静态是先存在的，对象是后存在的
     3.被所有对象共享
     4.可以直接被类名多调用

静态的使用注意事项：
1.静态方法只能访问静态成员（包括成员变量和成员方法）
   非静态方法可以访问静态也可以访问非静态
2.静态方法中不可以定义this，super关键字
   因为 一个类中，一个static变量只会有一个内存空间，虽然有多个类实例，但这些类实例中的这个static变量会共享
   同一个内存空间。静态方法在优先于对象存在，所以静态方法中不可以出现this，super关键字。
3.主函数是静态的。
  
静态的利弊：
   利：对 对象的共享数据进行单独空间的存储，节省空间，没有必要每一个对象中都存储一份，可以直接被类名所调用
   弊：生命周期过长，访问出现局限性（只能访问静态）

实例变量和类变量（static声明的变量）的区别：
1.存放位置
类变量随着类的加载存在于方法区中，实例变量随着对象的建立存在于堆内存里
2.生命周期
类变量生命周期最长，随着“类”的加载而加载，随着类的消失而消失
实例变量随着“对象”的消失而消失

-------------------------------------------------------------------------

如何实现多重继承
Q1: java中为什么不允许多重继承
A1: 片面的理解，父类是对一类具有共性事物的抽象，子类可以通过继承获取父类的一些属性。继承就好像一个孩子只能有一个爸爸一样。
多重继承的弊端: 子类可以继承父类中除private、构造器的一切属性和方法，如果在不override的情况下，两个父类含有相同的属性和方法，子类如何得知应该是使用哪一个呢？
有人会问，用接口来实现多继承，不同接口中也会有重名的方法啊。
接口中的方法都是抽象方法，是没有方法体的，具体的实现都需要实现类中进行，在重写的情况下，子类肯定会调用自己独有的方法。

-------------------------------------------------------------------------

spring依赖注入
依赖注入顾名思义就是a对象依赖于b对象，spring通过@Autowired注解，将b注入a，当前注入的前提是必须有a和b对象，既然a是主体，那么很显然需要先实例化，所以初始化的顺序就是a的Constructor,然后spring扫描到@Autowired注解，bean工厂创建b对象。
Q1: 如果想在a的构造函数中,即a初始化的时候需要用到b怎么办
A1: @PostConstruct注解，见名知意，在构造方法之后会被自动调用。

-------------------------------------------------------------------------

Q1: 类变量的初始化时机
A1: 父类静态 --- 子类静态 --- 父类成员（代码块）--- 父类构造 --- 子类成员（代码块）--- 子类构造

-------------------------------------------------------------------------

Q1: js运行环境的作用
A1: js是脚本语言，脚本语言的运行都需要解析器才能运行，对于运行在html中的js，浏览器充当，独立运行的js，node.js作为解析器。解析器即js的运行环境。
node.js是高性能的web服务器，通过异步单线程解决了传统apache服务器线程阻塞的弊端。

-------------------------------------------------------------------------

Q1: 线程
A1: 可独立运行的最小的CPU单位，可在同一进程内并发运行。

-------------------------------------------------------------------------

SpringBoot
1.SpringBoot程序启动后，会便利实现CommandLineRunner接口的实例，并执行他们的run方法，通过@Order注解指定执行顺序，同时要添加@Component注解；

-------------------------------------------------------------------------

React
1.web开发需要将数据实时反映在ui上，即频繁操作DOM元素，也是性能瓶颈的主要原因；
2.React为此引入了虚拟DOM，在浏览器端通过JavaScript实现了一套DOM API，每当数据变化时重载构建整个虚拟DOM树，对比前后两次变化，通过diff去更新实际DOM，
由于虚拟DOM树在内存中，所以性能极高。
3.React使用JSX代替JavaScript，允许在js中嵌套html，写起来也更像html，运行时需要编译成js，因为做了优化所以更快.

-------------------------------------------------------------------------

final
1.编译期常量，在类加载时候做初始化，运行期不会再改变，只能是基本数据类型；
2.运行期常量，既可以是基本数据类型，也可以是引用数据类型，引用数据类型是指其引用不变，但所指向的对象是可变的；
3.final修饰的方法不能被继承和更改的；
4.final修饰的类是不能被继承的，其成员可以是final或非final的，其方法会默认加上final；

-------------------------------------------------------------------------

数组
1.同一数据类型的集合;
2.数组的直接父类是Object，类名是[ + L + 全路径名 + 类名;
3.通过反射发现[I这个类是一个空类，没有任何成员变量、方法、构造器。

-------------------------------------------------------------------------

Q1: 为什么java中String获取长度使用成员方法length(),而数据使用成员变量length
A1: 数据的类型是[ + L + 内部类型，其中[ 的个数代表数组的维度，这不是一个合法的标识符，那么在JDK中肯定没有
显示的声明，所以，是JVM在运行期动态生成的，而JVM在动态生成[I类时没有生成length这个成员变量，jvm通过arraylength
这条指令来获取数组的长度，编译器将array.length语法处理成这样的指令，那么array.length()当然也可以处理。

-------------------------------------------------------------------------

Q1: 深克隆与浅克隆
A1: 浅克隆：使用已知实例对新建实例的成员变量逐个赋值，即只是传递信用，不能复制实例；
    深克隆：不仅复制对象的所有基本数据变量，还要为引用数据变量创建新实例，即对对象内部的引用均复制，是完全
    创建新的实例。

-------------------------------------------------------------------------

Q1: 时间频度T(n)
A1: 算法执行语句的次数，称之为语句频度或者时间频度,算法的耗时与语句执行次数成正比，其中n即指算法的规模，n不断
    变化，T(n)也不短变化，为找到变化规律，引入时间复杂度的概念。

Q2: 时间复杂度O(n)
Q2:

-------------------------------------------------------------------------

Enum枚举
1.枚举类常用于定义常量，可自定义属性和方法，属性类型要一一对应。

-------------------------------------------------------------------------

maven-surefire-plugin
1.maven通过该插件使用（mvn test命令）执行单元测试，在pom中配置TestNG依赖，即可自动识别；
2.通过‘<suiteXmlFile>testng.xml</suiteXmlFile>’标签指定；
3.也可以通过自己的标签配置运行哪些测试用例，类似于testng的xml文件配置。

-------------------------------------------------------------------------

jenkins节点
1.Jenkins的分布式构建基于节点配置，能偶让同一套代码或项目在不同环境中（Windows、Linux）中编译部署；
2.通过Jenkins节点配置，分布Jenkins工作空间，部署项目到不同的服务集群中，节点分为主节点和从节点（Master/SLave）,
从节点服务器不需要安装Jenkins服务，只需要运行节点服务即可，构建事件的分发由master执行；
3.从节点服务器上同样需要配置jdk/maven等；
4.从节点只是一个执行机，在当前工作目录下为构建job创建workspace，仍然有主节点（jenkins所在服务器进行调度），
archive归档文件等操作也保存在主服务器上；
5.从节点配置：
远程工作目录：类似于主服务器上jenkins的主目录；
启动方式：一般选择SSH方式；
主机：从节点部署的主机IP；
用户认证：在Credentials添加用户认证，通过用户名/密码的方式，也可以通过用户名/秘钥的方式，同时需要在从节点服务下.ssh中配置
master节点服务器的公钥（authorized_keys），免密ssh

java -jar jenkins.war --httpPort=8090
http://localhost:8090/exit(restart/reload)
net start(stop) jenkins


jenkins Publish ssh插件
1.在系统设置中配置SSH server，可通过秘钥或者用户名密码的方式进行配置，主要特别注意Remote Directory的配置，
在后面job中上传时都是基于此路径的相对路径，为了方便可以写成‘/’,那么job中的配置从‘Users/用户名’开始；
2.在job中配置 SSH Publishers，构建后操作选择'send build artifacts over SSH',从系统配置的SSH server中
选择一个目标服务器
‘Source files’：准备发布的源文件，根路径为.jenkins/workspace/${JOB_NAME}，所以此处填写相对路径即可，如target/*,
构建阶段执行shell或其他操作牵涉到文件路径均是如此;
'Remove prefix': 去掉匹配到的路径，如target/demo/a.txt,填写target的话拷贝过去则是demo/a.txt,没有目录会创建；
‘Remote directory’: 远程服务器的目标路径，相对于ssh server中设置的路径；
‘Exec command’: 上传后执行的操作，（如解压，部署，启动服务等操作）默认在远程服务器的家目录下。

jenkins邮件通知插件
1.系统管理-系统设置中配置系统管理员地址，即邮件都是从该邮箱发出；
2.配置邮件通知服务：
SMTP服务器：如stmp.163.com;
用户名/密码
3.构建后操作配置E-mail Notification，即收件地址；
4.邮件扩展插件 Extended E-mail Notification，可设置邮件模板，默认收件人（具体的格式抄送用“cc：”前缀，密送用“bcc：”前缀，不使用前缀默认为收件人）;
5.在job中构建后操作配置Editable Email Notification,收件人、主题、内容都可用插件配置的$DEFAULT_*设置，也可以自定义覆盖插件设置，
可选择attach build log发送构建日志的附件，或填写路径上传其他文件；
6.Triggers可自定义各种构建情况下将邮件发送给什么人，如最后一次代码提交人（Developers）,发起构建的人（Requestors），
也可以通过自定义收件人列表和邮件模板。

jenkins MultiJob插件
1.参数化构建时支持参数传递,通过${}形式在子job中获取；
2.创建多个MultiJob Phase，每个phase可以有多个job，必须是实现创建好的各类型job，运行时每个phase从上到下依次运行，phase内job
可以按顺序依次运行也可以并发。

-------------------------------------------------------------------------

Q1:./与sh的区别
A1:1.bash/sh 已经是可执行命令，脚本作为命令的参数，不存在可执行权限的问题，./必须具有可执行权限；
   2.sh执行脚本系统会产生子进程，在子进程定义变量结束后不会带到父进程中，.与source则是直接执行脚本，如果脚本里有定义或改变变量值，则
   在程序结束后依然有效。